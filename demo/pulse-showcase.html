<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RealWorldClaw ‚Äî Energy Core</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0a0f;--surface:#12121a;--border:#1e1e2e;
  --text:#e2e2e8;--dim:#6b6b80;--accent:#6366f1;--accent-glow:rgba(99,102,241,.35);
  --green:#22c55e;--emerald:#10b981;--orange:#f59e0b;--cyan:#06b6d4;--rose:#f43f5e;
}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.6;overflow-x:hidden}
code,.mono{font-family:'JetBrains Mono',monospace}

/* ‚îÄ‚îÄ Hero ‚îÄ‚îÄ */
.hero{text-align:center;padding:80px 24px 40px;position:relative}
.hero h1{font-size:clamp(1.8rem,5vw,3.2rem);font-weight:700;letter-spacing:-.02em}
.hero h1 span{background:linear-gradient(135deg,var(--accent),#a78bfa);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hero p{color:var(--dim);font-size:1.05rem;max-width:560px;margin:16px auto 0}

/* ‚îÄ‚îÄ Core Board Section ‚îÄ‚îÄ */
.core-section{display:flex;flex-direction:column;align-items:center;padding:40px 24px 60px;position:relative}
.core-label{font-size:.85rem;color:var(--accent);letter-spacing:.15em;text-transform:uppercase;margin-bottom:24px;font-weight:600}

/* 3D Canvas Container */
.board-wrap{position:relative;width:420px;height:420px;margin:0 auto;cursor:grab}
.board-wrap:active{cursor:grabbing}
.board-wrap canvas{width:100%!important;height:100%!important;border-radius:16px}
@media(max-width:640px){.board-wrap{width:300px;height:300px}}

.core-caption{margin-top:28px;text-align:center}
.core-caption h2{font-size:1.35rem;font-weight:600;margin-bottom:6px}
.core-caption p{color:var(--dim);font-size:.95rem;max-width:420px;margin:0 auto}
.core-hint{font-size:.75rem;color:var(--dim);margin-top:8px;opacity:.6}

/* ‚îÄ‚îÄ Forms Grid ‚îÄ‚îÄ */
.forms-section{position:relative;padding:20px 24px 80px;max-width:1200px;margin:0 auto}
.forms-section h2{text-align:center;font-size:1.6rem;font-weight:600;margin-bottom:48px}
.forms-section h2 span{color:var(--accent)}

.forms-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:24px}

/* Card */
.form-card{background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:28px;cursor:pointer;transition:all .35s ease;position:relative;overflow:hidden}
.form-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:var(--card-accent);opacity:.7;transition:opacity .3s}
.form-card:hover{border-color:var(--card-accent);transform:translateY(-4px);box-shadow:0 12px 40px rgba(0,0,0,.4)}
.form-card:hover::before{opacity:1}

.card-header{display:flex;align-items:center;gap:14px;margin-bottom:16px}
.card-icon{width:52px;height:52px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:1.5rem;background:rgba(255,255,255,.04);flex-shrink:0}
.card-title{font-size:1.15rem;font-weight:600}
.card-subtitle{font-size:.82rem;color:var(--dim);margin-top:2px}

.card-illustration{width:100%;height:140px;border-radius:10px;background:rgba(255,255,255,.02);margin-bottom:16px;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
.card-illustration canvas{width:100%!important;height:100%!important}

.card-tagline{font-size:.9rem;color:var(--dim);font-style:italic;margin-bottom:16px;padding-left:12px;border-left:2px solid var(--card-accent)}

/* Expandable Detail */
.card-detail{max-height:0;overflow:hidden;transition:max-height .4s ease}
.form-card.open .card-detail{max-height:400px}
.detail-inner{padding-top:16px;border-top:1px solid var(--border)}
.detail-inner h4{font-size:.8rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);margin-bottom:8px}
.sensor-list{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px}
.sensor-tag{font-size:.75rem;padding:3px 10px;border-radius:20px;background:rgba(255,255,255,.05);color:var(--text);border:1px solid var(--border)}
.ability-list{list-style:none;padding:0}
.ability-list li{font-size:.85rem;color:var(--dim);padding:3px 0}
.ability-list li::before{content:'‚Üí ';color:var(--card-accent)}

.expand-hint{font-size:.75rem;color:var(--dim);text-align:right;margin-top:8px;opacity:.6}

/* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
.footer{text-align:center;padding:60px 24px 80px;border-top:1px solid var(--border)}
.footer h2{font-size:clamp(1.4rem,4vw,2.4rem);font-weight:700;margin-bottom:12px}
.footer h2 span{color:var(--accent)}
.footer .steps{display:flex;flex-wrap:wrap;justify-content:center;gap:8px;margin-top:24px}
.footer .step{font-size:.85rem;padding:8px 16px;border-radius:8px;background:var(--surface);border:1px solid var(--border);color:var(--dim)}
.footer .step .arrow{color:var(--accent);margin-left:4px}
.footer .cta{display:inline-block;margin-top:32px;padding:14px 36px;border-radius:10px;background:var(--accent);color:#fff;font-weight:600;text-decoration:none;font-size:1rem;transition:all .3s}
.footer .cta:hover{box-shadow:0 0 30px var(--accent-glow);transform:translateY(-2px)}

@media(max-width:640px){
  .forms-grid{grid-template-columns:1fr}
}
</style>
</head>
<body>

<!-- Hero -->
<section class="hero">
  <h1><span>Energy Core</span></h1>
  <p>A standardized AI core board. Print a body, add sensors, bring it to life.</p>
</section>

<!-- Core Board -->
<section class="core-section" id="core-section">
  <div class="core-label mono">The Brain</div>
  <div class="board-wrap" id="board-wrap"></div>
  <div class="core-caption">
    <h2>This is the brain. Everything starts here.</h2>
    <p>A √∏42mm circular core board with ESP32-S3, round OLED display, audio codec, WiFi/BLE, and RWC Bus expansion. The universal AI heart for any physical form.</p>
    <div class="core-hint mono">drag to rotate ¬∑ scroll to zoom</div>
  </div>
</section>

<!-- Forms -->
<section class="forms-section" id="forms-section">
  <h2>One Core. <span>Five Forms.</span></h2>
  <div class="forms-grid">

    <!-- Desktop Companion -->
    <div class="form-card" style="--card-accent:#6366f1" onclick="this.classList.toggle('open')">
      <div class="card-header">
        <div class="card-icon">üè†</div>
        <div><div class="card-title">Desktop Companion</div><div class="card-subtitle">Ê°åÈù¢‰º¥‰æ£</div></div>
      </div>
      <div class="card-illustration" data-form="desktop"></div>
      <div class="card-tagline">The simplest form ‚Äî Energy Core's first home.</div>
      <div class="expand-hint mono">tap to expand ‚Üì</div>
      <div class="card-detail"><div class="detail-inner">
        <h4>Sensors</h4>
        <div class="sensor-list">
          <span class="sensor-tag">Built-in mic</span>
          <span class="sensor-tag">Built-in speaker</span>
          <span class="sensor-tag">Round OLED</span>
        </div>
        <h4>AI Capabilities</h4>
        <ul class="ability-list">
          <li>Natural conversation &amp; voice assistant</li>
          <li>Expressive emoji animations</li>
          <li>Desktop AI companion &amp; timer</li>
        </ul>
      </div></div>
    </div>

    <!-- Plant Guardian -->
    <div class="form-card" style="--card-accent:#22c55e" onclick="this.classList.toggle('open')">
      <div class="card-header">
        <div class="card-icon">üåø</div>
        <div><div class="card-title">Plant Guardian</div><div class="card-subtitle">Ê§çÁâ©ÂÆàÊä§ËÄÖ</div></div>
      </div>
      <div class="card-illustration" data-form="plant"></div>
      <div class="card-tagline">Your AI gardener, living in the flowerpot.</div>
      <div class="expand-hint mono">tap to expand ‚Üì</div>
      <div class="card-detail"><div class="detail-inner">
        <h4>Sensors</h4>
        <div class="sensor-list">
          <span class="sensor-tag">Soil moisture</span>
          <span class="sensor-tag">Mini water pump</span>
          <span class="sensor-tag">Light sensor</span>
        </div>
        <h4>AI Capabilities</h4>
        <ul class="ability-list">
          <li>Automatic watering based on soil data</li>
          <li>Plant health monitoring &amp; alerts</li>
          <li>Growth tracking over time</li>
        </ul>
      </div></div>
    </div>

    <!-- Kitchen Brain -->
    <div class="form-card" style="--card-accent:#f59e0b" onclick="this.classList.toggle('open')">
      <div class="card-header">
        <div class="card-icon">‚öñÔ∏è</div>
        <div><div class="card-title">Kitchen Brain</div><div class="card-subtitle">Âé®ÊàøÂ§ßËÑë</div></div>
      </div>
      <div class="card-illustration" data-form="kitchen"></div>
      <div class="card-tagline">Your AI nutritionist, guarding the kitchen.</div>
      <div class="expand-hint mono">tap to expand ‚Üì</div>
      <div class="card-detail"><div class="detail-inner">
        <h4>Sensors</h4>
        <div class="sensor-list">
          <span class="sensor-tag">Load cell (scale)</span>
          <span class="sensor-tag">Camera (optional)</span>
        </div>
        <h4>AI Capabilities</h4>
        <ul class="ability-list">
          <li>Food recognition &amp; weight measurement</li>
          <li>Nutrition tracking &amp; meal suggestions</li>
          <li>Voice-guided recipe instructions</li>
        </ul>
      </div></div>
    </div>

    <!-- Home Sentinel -->
    <div class="form-card" style="--card-accent:#06b6d4" onclick="this.classList.toggle('open')">
      <div class="card-header">
        <div class="card-icon">üå°Ô∏è</div>
        <div><div class="card-title">Home Sentinel</div><div class="card-subtitle">ÂÆ∂Â∫≠Âì®ÂÖµ</div></div>
      </div>
      <div class="card-illustration" data-form="sentinel"></div>
      <div class="card-tagline">Your AI environment butler, guarding every breath.</div>
      <div class="expand-hint mono">tap to expand ‚Üì</div>
      <div class="card-detail"><div class="detail-inner">
        <h4>Sensors</h4>
        <div class="sensor-list">
          <span class="sensor-tag">Temp &amp; humidity</span>
          <span class="sensor-tag">PM2.5</span>
          <span class="sensor-tag">Ambient light</span>
        </div>
        <h4>AI Capabilities</h4>
        <ul class="ability-list">
          <li>Real-time environment monitoring</li>
          <li>Health &amp; comfort suggestions</li>
          <li>Smart home integration &amp; automation</li>
        </ul>
      </div></div>
    </div>

    <!-- Explorer -->
    <div class="form-card" style="--card-accent:#f43f5e" onclick="this.classList.toggle('open')">
      <div class="card-header">
        <div class="card-icon">ü§ñ</div>
        <div><div class="card-title">Explorer</div><div class="card-subtitle">Êé¢Á¥¢ËÄÖ</div></div>
      </div>
      <div class="card-illustration" data-form="explorer"></div>
      <div class="card-tagline">Your AI adventurer, walking the physical world.</div>
      <div class="expand-hint mono">tap to expand ‚Üì</div>
      <div class="card-detail"><div class="detail-inner">
        <h4>Sensors</h4>
        <div class="sensor-list">
          <span class="sensor-tag">Servos (√ó4)</span>
          <span class="sensor-tag">Camera</span>
          <span class="sensor-tag">Distance sensor</span>
          <span class="sensor-tag">IMU</span>
        </div>
        <h4>AI Capabilities</h4>
        <ul class="ability-list">
          <li>Autonomous navigation &amp; obstacle avoidance</li>
          <li>Visual exploration &amp; mapping</li>
          <li>Patrol &amp; surveillance routines</li>
        </ul>
      </div></div>
    </div>

  </div>
</section>

<!-- Footer -->
<section class="footer">
  <h2>One Core. <span>Infinite Forms.</span></h2>
  <div class="steps">
    <div class="step">Download STL files<span class="arrow">‚Üí</span></div>
    <div class="step">Print a body<span class="arrow">‚Üí</span></div>
    <div class="step">Install Energy Core<span class="arrow">‚Üí</span></div>
    <div class="step">Your AI comes alive</div>
  </div>
  <a href="#" class="cta">Get Energy Core</a>
</section>

<!-- Three.js -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENERGY CORE 3D MODEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(function initEnergyCore() {
  const container = document.getElementById('board-wrap');
  const w = container.clientWidth, h = container.clientHeight;

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Camera
  const camera = new THREE.PerspectiveCamera(35, w / h, 0.1, 100);
  camera.position.set(0, 1.8, 3.2);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.enablePan = false;
  controls.minDistance = 2;
  controls.maxDistance = 6;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 1.5;
  controls.target.set(0, 0, 0);

  let idleTimer;
  controls.addEventListener('start', () => { controls.autoRotate = false; clearTimeout(idleTimer); });
  controls.addEventListener('end', () => { idleTimer = setTimeout(() => controls.autoRotate = true, 3000); });

  // ‚îÄ‚îÄ Environment (procedural studio) ‚îÄ‚îÄ
  const pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  const envScene = new THREE.Scene();
  envScene.background = new THREE.Color(0x222233);
  // Soft area lights baked into env
  const envLight1 = new THREE.Mesh(new THREE.PlaneGeometry(6, 3), new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
  envLight1.position.set(0, 3, -2);
  envLight1.lookAt(0, 0, 0);
  envScene.add(envLight1);
  const envLight2 = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), new THREE.MeshBasicMaterial({ color: 0x8888ff, side: THREE.DoubleSide }));
  envLight2.position.set(-3, 1, 2);
  envLight2.lookAt(0, 0, 0);
  envScene.add(envLight2);
  const envLight3 = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), new THREE.MeshBasicMaterial({ color: 0xffddcc, side: THREE.DoubleSide }));
  envLight3.position.set(3, 2, 1);
  envLight3.lookAt(0, 0, 0);
  envScene.add(envLight3);
  scene.environment = pmrem.fromScene(envScene, 0.04).texture;
  envScene.traverse(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
  pmrem.dispose();

  // ‚îÄ‚îÄ Three-point lighting ‚îÄ‚îÄ
  const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
  keyLight.position.set(3, 5, 4);
  scene.add(keyLight);
  const fillLight = new THREE.DirectionalLight(0x8888ff, 0.6);
  fillLight.position.set(-4, 2, 2);
  scene.add(fillLight);
  const rimLight = new THREE.DirectionalLight(0xffeedd, 1.0);
  rimLight.position.set(0, 3, -4);
  scene.add(rimLight);
  scene.add(new THREE.AmbientLight(0x404060, 0.4));

  // ‚îÄ‚îÄ Materials ‚îÄ‚îÄ
  // PCB texture
  const pcbCanvas = document.createElement('canvas');
  pcbCanvas.width = 512; pcbCanvas.height = 512;
  const pctx = pcbCanvas.getContext('2d');
  // FR4 green base
  pctx.fillStyle = '#1a4a2e';
  pctx.fillRect(0, 0, 512, 512);
  // Subtle grid/trace pattern
  pctx.strokeStyle = '#2a6a3e';
  pctx.lineWidth = 0.5;
  for (let i = 0; i < 512; i += 16) {
    pctx.beginPath(); pctx.moveTo(i, 0); pctx.lineTo(i, 512); pctx.stroke();
    pctx.beginPath(); pctx.moveTo(0, i); pctx.lineTo(512, i); pctx.stroke();
  }
  // Copper traces
  pctx.strokeStyle = '#c8a84e';
  pctx.lineWidth = 1.5;
  const traces = [
    [[256,256],[256,140],[180,140],[180,80]],
    [[256,256],[340,256],[340,140],[400,140]],
    [[256,256],[256,380],[180,380],[180,440]],
    [[256,256],[340,256],[400,300]],
    [[256,256],[140,256],[80,200]],
    [[256,256],[140,256],[80,320]],
    [[256,256],[380,256],[440,220]],
    [[256,256],[380,256],[440,340]],
  ];
  traces.forEach(pts => {
    pctx.beginPath();
    pctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) pctx.lineTo(pts[i][0], pts[i][1]);
    pctx.stroke();
  });
  // Via holes (small dots along traces)
  pctx.fillStyle = '#c8a84e';
  [[180,140],[340,140],[180,380],[400,300],[80,200],[80,320],[440,220],[440,340]].forEach(([x,y]) => {
    pctx.beginPath(); pctx.arc(x, y, 4, 0, Math.PI*2); pctx.fill();
    pctx.fillStyle = '#1a4a2e';
    pctx.beginPath(); pctx.arc(x, y, 2, 0, Math.PI*2); pctx.fill();
    pctx.fillStyle = '#c8a84e';
  });

  const pcbTexture = new THREE.CanvasTexture(pcbCanvas);

  const pcbMat = new THREE.MeshPhysicalMaterial({
    map: pcbTexture,
    roughness: 0.6,
    metalness: 0.1,
    color: 0x1a5a30,
  });

  const chipMat = new THREE.MeshPhysicalMaterial({
    color: 0x1a1a1e,
    roughness: 0.3,
    metalness: 0.4,
  });

  const goldMat = new THREE.MeshPhysicalMaterial({
    color: 0xd4a847,
    roughness: 0.2,
    metalness: 0.9,
  });

  const whitePlasticMat = new THREE.MeshPhysicalMaterial({
    color: 0xe8e8e0,
    roughness: 0.5,
    metalness: 0.0,
  });

  // ‚îÄ‚îÄ Screen face texture (animated) ‚îÄ‚îÄ
  const screenCanvas = document.createElement('canvas');
  screenCanvas.width = 256; screenCanvas.height = 256;
  const sctx = screenCanvas.getContext('2d');
  const screenTexture = new THREE.CanvasTexture(screenCanvas);

  const screenMat = new THREE.MeshPhysicalMaterial({
    map: screenTexture,
    emissiveMap: screenTexture,
    emissive: new THREE.Color(0x6366f1),
    emissiveIntensity: 0.8,
    roughness: 0.05,
    metalness: 0.0,
    clearcoat: 1.0,
    clearcoatRoughness: 0.05,
  });

  // ‚îÄ‚îÄ Build the PCB ‚îÄ‚îÄ
  const boardGroup = new THREE.Group();

  // Main circular PCB (scale: 1 unit ‚âà 21mm, so radius=1)
  const pcbGeo = new THREE.CylinderGeometry(1, 1, 0.08, 64);
  const pcbMesh = new THREE.Mesh(pcbGeo, pcbMat);
  boardGroup.add(pcbMesh);

  // Solder mask ring (edge highlight)
  const edgeGeo = new THREE.TorusGeometry(1, 0.015, 8, 64);
  edgeGeo.rotateX(Math.PI / 2);
  const edgeTop = new THREE.Mesh(edgeGeo, goldMat);
  edgeTop.position.y = 0.04;
  boardGroup.add(edgeTop);
  const edgeBot = edgeTop.clone();
  edgeBot.position.y = -0.04;
  boardGroup.add(edgeBot);

  // ‚îÄ‚îÄ Central round screen ‚îÄ‚îÄ
  const screenGeo = new THREE.CylinderGeometry(0.44, 0.44, 0.02, 48);
  const screenBezelGeo = new THREE.CylinderGeometry(0.48, 0.48, 0.03, 48);
  const bezelMesh = new THREE.Mesh(screenBezelGeo, chipMat);
  bezelMesh.position.y = 0.05;
  boardGroup.add(bezelMesh);
  const screenMesh = new THREE.Mesh(screenGeo, screenMat);
  screenMesh.position.y = 0.065;
  boardGroup.add(screenMesh);

  // ‚îÄ‚îÄ ESP32-S3 chip (QFN package) ‚îÄ‚îÄ
  const esp32Geo = new THREE.BoxGeometry(0.28, 0.04, 0.28);
  const esp32 = new THREE.Mesh(esp32Geo, chipMat);
  esp32.position.set(0, 0.06, 0.55);
  boardGroup.add(esp32);
  // QFN pads on each side
  for (let side = 0; side < 4; side++) {
    for (let i = 0; i < 5; i++) {
      const pad = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.005, 0.035), goldMat);
      const offset = (i - 2) * 0.05;
      if (side === 0) pad.position.set(offset, 0.045, 0.55 - 0.15);
      else if (side === 1) pad.position.set(offset, 0.045, 0.55 + 0.15);
      else if (side === 2) { pad.rotation.y = Math.PI/2; pad.position.set(-0.15, 0.045, 0.55 + offset); }
      else { pad.rotation.y = Math.PI/2; pad.position.set(0.15, 0.045, 0.55 + offset); }
      boardGroup.add(pad);
    }
  }
  // Label
  // (skip text mesh for perf ‚Äî the chip is recognizable by shape)

  // ‚îÄ‚îÄ PSRAM chip ‚îÄ‚îÄ
  const psramGeo = new THREE.BoxGeometry(0.18, 0.03, 0.14);
  const psram = new THREE.Mesh(psramGeo, chipMat);
  psram.position.set(-0.55, 0.055, 0.35);
  boardGroup.add(psram);

  // ‚îÄ‚îÄ Audio codec chip ‚îÄ‚îÄ
  const codecGeo = new THREE.BoxGeometry(0.2, 0.03, 0.2);
  const codec = new THREE.Mesh(codecGeo, chipMat);
  codec.position.set(0.5, 0.055, -0.4);
  boardGroup.add(codec);

  // ‚îÄ‚îÄ Power regulator ‚îÄ‚îÄ
  const regGeo = new THREE.BoxGeometry(0.12, 0.025, 0.1);
  const reg = new THREE.Mesh(regGeo, chipMat);
  reg.position.set(-0.5, 0.053, -0.5);
  boardGroup.add(reg);

  // ‚îÄ‚îÄ MEMS microphone ‚îÄ‚îÄ
  const micGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16);
  const mic = new THREE.Mesh(micGeo, chipMat);
  mic.position.set(0.7, 0.055, 0);
  boardGroup.add(mic);
  // Mic port hole
  const micHole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.04, 12), new THREE.MeshBasicMaterial({ color: 0x050505 }));
  micHole.position.set(0.7, 0.065, 0);
  boardGroup.add(micHole);

  // ‚îÄ‚îÄ RWC Bus: 8 Pogo Pin pads (golden circles around edge) ‚îÄ‚îÄ
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    const px = Math.cos(angle) * 0.85;
    const pz = Math.sin(angle) * 0.85;
    const padGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.01, 16);
    const pad = new THREE.Mesh(padGeo, goldMat);
    pad.position.set(px, 0.045, pz);
    boardGroup.add(pad);
    // Center contact dot
    const dot = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.015, 12), goldMat);
    dot.position.set(px, 0.055, pz);
    boardGroup.add(dot);
  }

  // ‚îÄ‚îÄ JST battery connector ‚îÄ‚îÄ
  const jstGeo = new THREE.BoxGeometry(0.12, 0.06, 0.08);
  const jst = new THREE.Mesh(jstGeo, whitePlasticMat);
  jst.position.set(-0.7, 0.07, -0.15);
  boardGroup.add(jst);
  // Connector opening
  const jstHole = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.03, 0.05), new THREE.MeshBasicMaterial({ color: 0x333333 }));
  jstHole.position.set(-0.7, 0.075, -0.12);
  boardGroup.add(jstHole);

  // ‚îÄ‚îÄ 4 mounting holes ‚îÄ‚îÄ
  const mountPositions = [[0.75, 0.75], [-0.75, 0.75], [0.75, -0.75], [-0.75, -0.75]];
  mountPositions.forEach(([x, z]) => {
    // Limit to circle
    const dist = Math.sqrt(x*x + z*z);
    if (dist > 0.95) return;
    const mountOuter = new THREE.Mesh(new THREE.TorusGeometry(0.06, 0.015, 8, 16), goldMat);
    mountOuter.rotation.x = Math.PI / 2;
    mountOuter.position.set(x, 0.045, z);
    boardGroup.add(mountOuter);
  });
  // Place them at 45¬∞ angles within the circle
  const mountAngles = [Math.PI*0.25, Math.PI*0.75, Math.PI*1.25, Math.PI*1.75];
  mountAngles.forEach(a => {
    const mx = Math.cos(a) * 0.82, mz = Math.sin(a) * 0.82;
    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.012, 8, 16), goldMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.set(mx, 0.045, mz);
    boardGroup.add(ring);
    const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 12), new THREE.MeshBasicMaterial({ color: 0x080808 }));
    hole.position.set(mx, 0, mz);
    boardGroup.add(hole);
  });

  // ‚îÄ‚îÄ Back side components ‚îÄ‚îÄ
  // Speaker holes (ring of small holes on back)
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * Math.PI * 2;
    const sx = Math.cos(a) * 0.3, sz = Math.sin(a) * 0.3;
    const sHole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8), new THREE.MeshBasicMaterial({ color: 0x060606 }));
    sHole.position.set(sx, -0.02, sz);
    boardGroup.add(sHole);
  }

  // Battery pad area (back)
  const battPad = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.005, 0.35), goldMat);
  battPad.position.set(0, -0.043, 0.4);
  boardGroup.add(battPad);

  // Antenna keep-out zone marking (back)
  const antGeo = new THREE.TorusGeometry(0.2, 0.008, 8, 32, Math.PI);
  const antMark = new THREE.Mesh(antGeo, new THREE.MeshBasicMaterial({ color: 0xdddddd }));
  antMark.rotation.x = Math.PI / 2;
  antMark.position.set(0, -0.043, -0.55);
  boardGroup.add(antMark);

  // Passive components (tiny rectangles - capacitors/resistors)
  const passiveGeo = new THREE.BoxGeometry(0.04, 0.02, 0.02);
  const passiveMat = new THREE.MeshPhysicalMaterial({ color: 0x2a2a2e, roughness: 0.4, metalness: 0.3 });
  [[0.3, 0.35], [-0.3, 0.5], [0.4, -0.2], [-0.35, -0.35], [0.15, 0.7], [-0.15, -0.65], [0.6, 0.2], [-0.55, 0.15]].forEach(([x,z]) => {
    const p = new THREE.Mesh(passiveGeo, passiveMat);
    p.position.set(x, 0.05, z);
    boardGroup.add(p);
    // Gold end caps
    const cap1 = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.02, 0.022), goldMat);
    cap1.position.set(x - 0.018, 0.05, z);
    boardGroup.add(cap1);
    const cap2 = cap1.clone();
    cap2.position.set(x + 0.018, 0.05, z);
    boardGroup.add(cap2);
  });

  scene.add(boardGroup);

  // ‚îÄ‚îÄ Post-processing ‚îÄ‚îÄ
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(w, h), 0.3, 0.5, 0.8);
  composer.addPass(bloom);

  // ‚îÄ‚îÄ Screen animation ‚îÄ‚îÄ
  let blinkTimer = 0;
  let isBlinking = false;
  let breathPhase = 0;

  function drawFace(time) {
    sctx.clearRect(0, 0, 256, 256);
    // Background gradient
    const grad = sctx.createRadialGradient(128, 128, 20, 128, 128, 128);
    grad.addColorStop(0, '#6366f1');
    grad.addColorStop(1, '#312e81');
    sctx.fillStyle = grad;
    sctx.beginPath();
    sctx.arc(128, 128, 128, 0, Math.PI * 2);
    sctx.fill();

    // Breathing glow
    breathPhase += 0.02;
    const breathAlpha = 0.15 + Math.sin(breathPhase) * 0.1;
    sctx.fillStyle = `rgba(255,255,255,${breathAlpha})`;
    sctx.beginPath();
    sctx.arc(128, 128, 80, 0, Math.PI * 2);
    sctx.fill();

    // Eyes
    sctx.fillStyle = '#ffffff';
    const eyeY = 110;
    const eyeOpenness = isBlinking ? 2 : 18;
    // Left eye
    sctx.beginPath();
    sctx.ellipse(98, eyeY, 14, eyeOpenness, 0, 0, Math.PI * 2);
    sctx.fill();
    // Right eye
    sctx.beginPath();
    sctx.ellipse(158, eyeY, 14, eyeOpenness, 0, 0, Math.PI * 2);
    sctx.fill();

    // Smile
    sctx.strokeStyle = '#ffffff';
    sctx.lineWidth = 3.5;
    sctx.lineCap = 'round';
    sctx.beginPath();
    sctx.arc(128, 130, 35, 0.15 * Math.PI, 0.85 * Math.PI);
    sctx.stroke();

    // Blink logic
    blinkTimer += 1;
    if (!isBlinking && blinkTimer > 120 + Math.random() * 180) {
      isBlinking = true;
      blinkTimer = 0;
    }
    if (isBlinking && blinkTimer > 6) {
      isBlinking = false;
      blinkTimer = 0;
    }

    screenTexture.needsUpdate = true;
  }

  // ‚îÄ‚îÄ Animate ‚îÄ‚îÄ
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    drawFace(clock.getElapsedTime());
    composer.render();
  }
  animate();

  // ‚îÄ‚îÄ Resize ‚îÄ‚îÄ
  window.addEventListener('resize', () => {
    const nw = container.clientWidth, nh = container.clientHeight;
    camera.aspect = nw / nh;
    camera.updateProjectionMatrix();
    renderer.setSize(nw, nh);
    composer.setSize(nw, nh);
  });
})();


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WIREFRAME FORM PREVIEWS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(function initFormPreviews() {
  const forms = {
    desktop: buildDesktop,
    plant: buildPlant,
    kitchen: buildKitchen,
    sentinel: buildSentinel,
    explorer: buildExplorer,
  };

  const colors = {
    desktop: 0x6366f1,
    plant: 0x22c55e,
    kitchen: 0xf59e0b,
    sentinel: 0x06b6d4,
    explorer: 0xf43f5e,
  };

  document.querySelectorAll('.card-illustration[data-form]').forEach(el => {
    const formType = el.dataset.form;
    if (!forms[formType]) return;

    const w = el.clientWidth || 300, h = el.clientHeight || 140;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(w, h);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    el.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30, w / h, 0.1, 50);
    camera.position.set(0, 1.5, 4);
    camera.lookAt(0, 0.3, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dl = new THREE.DirectionalLight(0xffffff, 1);
    dl.position.set(2, 3, 3);
    scene.add(dl);

    const wireColor = colors[formType];
    const wireMat = new THREE.MeshBasicMaterial({ color: wireColor, wireframe: true, transparent: true, opacity: 0.6 });
    const solidMat = new THREE.MeshBasicMaterial({ color: wireColor, transparent: true, opacity: 0.08 });

    const group = forms[formType](wireMat, solidMat);
    scene.add(group);

    let frame = 0;
    function anim() {
      requestAnimationFrame(anim);
      frame++;
      group.rotation.y = Math.sin(frame * 0.008) * 0.4;
      renderer.render(scene, camera);
    }
    anim();

    // Resize observer
    const ro = new ResizeObserver(entries => {
      const { width: rw, height: rh } = entries[0].contentRect;
      if (rw > 0 && rh > 0) {
        camera.aspect = rw / rh;
        camera.updateProjectionMatrix();
        renderer.setSize(rw, rh);
      }
    });
    ro.observe(el);
  });

  // ‚îÄ‚îÄ Form builders ‚îÄ‚îÄ
  function buildDesktop(wireMat, solidMat) {
    const g = new THREE.Group();
    // Egg/sphere body
    const bodyGeo = new THREE.SphereGeometry(0.7, 16, 12);
    bodyGeo.scale(1, 1.2, 1);
    g.add(new THREE.Mesh(bodyGeo, wireMat));
    g.add(new THREE.Mesh(bodyGeo, solidMat));
    // Screen circle
    const screenGeo = new THREE.CircleGeometry(0.3, 24);
    const screenMesh = new THREE.Mesh(screenGeo, new THREE.MeshBasicMaterial({ color: wireMat.color, transparent: true, opacity: 0.3 }));
    screenMesh.position.set(0, 0.15, 0.68);
    g.add(screenMesh);
    // Base
    const baseGeo = new THREE.CylinderGeometry(0.5, 0.55, 0.1, 24);
    const base = new THREE.Mesh(baseGeo, wireMat);
    base.position.y = -0.85;
    g.add(base);
    return g;
  }

  function buildPlant(wireMat, solidMat) {
    const g = new THREE.Group();
    // Clip body
    const clipGeo = new THREE.BoxGeometry(0.3, 1.2, 0.25);
    g.add(new THREE.Mesh(clipGeo, wireMat));
    g.add(new THREE.Mesh(clipGeo, solidMat));
    // Clip jaw (two halves)
    const jawGeo = new THREE.BoxGeometry(0.35, 0.15, 0.3);
    const jaw1 = new THREE.Mesh(jawGeo, wireMat);
    jaw1.position.set(0, -0.65, 0);
    g.add(jaw1);
    const jaw2 = new THREE.Mesh(jawGeo, wireMat);
    jaw2.position.set(0, -0.85, 0);
    g.add(jaw2);
    // Screen dot
    const dotGeo = new THREE.SphereGeometry(0.08, 12, 12);
    const dot = new THREE.Mesh(dotGeo, new THREE.MeshBasicMaterial({ color: wireMat.color, transparent: true, opacity: 0.5 }));
    dot.position.set(0, 0.2, 0.13);
    g.add(dot);
    g.position.y = 0.3;
    return g;
  }

  function buildKitchen(wireMat, solidMat) {
    const g = new THREE.Group();
    // Base platform
    const baseGeo = new THREE.CylinderGeometry(0.7, 0.75, 0.12, 24);
    const base = new THREE.Mesh(baseGeo, wireMat);
    g.add(base);
    g.add(new THREE.Mesh(baseGeo, solidMat));
    // Stand
    const standGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 12);
    const stand = new THREE.Mesh(standGeo, wireMat);
    stand.position.y = 0.36;
    g.add(stand);
    // Screen head (tilted disc)
    const headGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.06, 24);
    const head = new THREE.Mesh(headGeo, wireMat);
    head.position.set(0, 0.75, -0.05);
    head.rotation.x = -0.3;
    g.add(head);
    const headSolid = new THREE.Mesh(headGeo, solidMat);
    headSolid.position.copy(head.position);
    headSolid.rotation.copy(head.rotation);
    g.add(headSolid);
    g.position.y = -0.2;
    return g;
  }

  function buildSentinel(wireMat, solidMat) {
    const g = new THREE.Group();
    // Wall-mount box
    const boxGeo = new THREE.BoxGeometry(0.8, 1.1, 0.25);
    g.add(new THREE.Mesh(boxGeo, wireMat));
    g.add(new THREE.Mesh(boxGeo, solidMat));
    // Screen circle
    const screenGeo = new THREE.CircleGeometry(0.2, 20);
    const screen = new THREE.Mesh(screenGeo, new THREE.MeshBasicMaterial({ color: wireMat.color, transparent: true, opacity: 0.3 }));
    screen.position.set(0, 0.15, 0.13);
    g.add(screen);
    // Sensor dots at bottom
    for (let i = -1; i <= 1; i++) {
      const d = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), wireMat);
      d.position.set(i * 0.15, -0.35, 0.13);
      g.add(d);
    }
    // Mount bracket
    const bracket = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.06, 0.06), wireMat);
    bracket.position.set(0, 0.6, -0.1);
    g.add(bracket);
    return g;
  }

  function buildExplorer(wireMat, solidMat) {
    const g = new THREE.Group();
    // Chassis
    const chassisGeo = new THREE.BoxGeometry(1.2, 0.3, 0.8);
    g.add(new THREE.Mesh(chassisGeo, wireMat));
    g.add(new THREE.Mesh(chassisGeo, solidMat));
    // Wheels
    const wheelGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
    const positions = [[-0.55, -0.2, 0.45], [0.55, -0.2, 0.45], [-0.55, -0.2, -0.45], [0.55, -0.2, -0.45]];
    positions.forEach(([x, y, z]) => {
      const wheel = new THREE.Mesh(wheelGeo, wireMat);
      wheel.rotation.x = Math.PI / 2;
      wheel.position.set(x, y, z);
      g.add(wheel);
    });
    // Eye/camera dome
    const domeGeo = new THREE.SphereGeometry(0.15, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
    const dome = new THREE.Mesh(domeGeo, wireMat);
    dome.position.set(0, 0.15, 0);
    g.add(dome);
    g.position.y = -0.1;
    return g;
  }
})();


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONNECTION LINES (preserved from original)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(function(){
  const canvas=document.createElement('canvas');
  canvas.style.cssText='position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1';
  document.body.appendChild(canvas);
  const ctx=canvas.getContext('2d');
  let w,h,coreRect,cardRects=[],frame=0;

  function resize(){
    w=canvas.width=window.innerWidth;
    h=canvas.height=window.innerHeight;
  }

  function getPositions(){
    const board=document.getElementById('board-wrap');
    if(!board)return;
    const br=board.getBoundingClientRect();
    coreRect={x:br.left+br.width/2, y:br.top+br.height/2};
    cardRects=[];
    document.querySelectorAll('.form-card').forEach(c=>{
      const r=c.getBoundingClientRect();
      cardRects.push({x:r.left+r.width/2, y:r.top, el:c});
    });
  }

  function draw(){
    frame++;
    ctx.clearRect(0,0,w,h);
    if(!coreRect||!cardRects.length)return;
    const coreY=coreRect.y;
    cardRects.forEach((card,i)=>{
      const dx=card.x-coreRect.x;
      const dy=card.y-coreY;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist>800||card.y<0||coreY>h)return;
      const progress=(Math.sin(frame*.015+i*1.2)+1)/2;
      const alpha=Math.max(0,.12-dist/8000);
      ctx.beginPath();
      ctx.moveTo(coreRect.x,coreY);
      const cpx=coreRect.x+dx*.5;
      const cpy=coreY+dy*.3;
      ctx.quadraticCurveTo(cpx,cpy,card.x,card.y);
      ctx.strokeStyle=`rgba(99,102,241,${alpha})`;
      ctx.lineWidth=1;
      ctx.stroke();
      const t=progress;
      const px=(1-t)*(1-t)*coreRect.x+2*(1-t)*t*cpx+t*t*card.x;
      const py=(1-t)*(1-t)*coreY+2*(1-t)*t*cpy+t*t*card.y;
      ctx.beginPath();
      ctx.arc(px,py,2.5,0,Math.PI*2);
      ctx.fillStyle=`rgba(99,102,241,${alpha*3})`;
      ctx.fill();
    });
  }

  function loop(){
    getPositions();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('resize',resize);
  resize();
  loop();
})();
</script>
</body>
</html>
