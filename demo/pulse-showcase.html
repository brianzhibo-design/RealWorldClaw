<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pulse â€” RealWorldClaw</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  background: #0a0a0f; color: #fff; font-family: 'Inter', sans-serif; 
  overflow: hidden; width: 100vw; height: 100vh;
}
#canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
canvas { display: block; }

/* UI Overlay */
.ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
.ui-overlay > * { pointer-events: auto; }

.brand {
  position: absolute; top: 40px; left: 48px;
}
.brand h1 {
  font-size: 48px; font-weight: 800; letter-spacing: -1.5px;
  background: linear-gradient(135deg, #e0e0ff 0%, #a0a0ff 50%, #6366f1 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text; line-height: 1.1;
}
.brand p {
  font-size: 14px; font-weight: 400; color: rgba(255,255,255,0.45);
  margin-top: 8px; letter-spacing: 2px; text-transform: uppercase;
}

/* Module buttons */
.module-bar {
  position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 12px;
}
.module-btn {
  padding: 12px 28px; border-radius: 50px; border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.04); backdrop-filter: blur(20px);
  color: rgba(255,255,255,0.7); font-family: 'Inter', sans-serif;
  font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
  display: flex; align-items: center; gap: 8px; letter-spacing: 0.5px;
}
.module-btn:hover {
  background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.25);
  color: #fff;
}
.module-btn.active {
  border-color: rgba(99,102,241,0.6); background: rgba(99,102,241,0.15);
  color: #a5b4fc;
}
.module-btn .dot {
  width: 8px; height: 8px; border-radius: 50%;
}
.module-btn.green .dot { background: #4ade80; }
.module-btn.blue .dot { background: #60a5fa; }
.module-btn.gray .dot { background: #9ca3af; }

/* Info panel */
.info-panel {
  position: absolute; top: 50%; right: 48px; transform: translateY(-50%);
  width: 240px; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease;
  transform: translateY(-50%) translateX(20px);
}
.info-panel.visible {
  opacity: 1; transform: translateY(-50%) translateX(0);
}
.info-panel h3 {
  font-size: 16px; font-weight: 600; margin-bottom: 8px;
  color: rgba(255,255,255,0.9);
}
.info-panel .capability {
  padding: 10px 14px; border-radius: 10px; margin-bottom: 8px;
  background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
  font-size: 12px; color: rgba(255,255,255,0.6); line-height: 1.5;
}
.info-panel .capability .cap-title {
  font-weight: 600; color: rgba(255,255,255,0.85); margin-bottom: 2px;
}

/* Loading */
.loader {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  background: #0a0a0f; display: flex; align-items: center; justify-content: center;
  flex-direction: column; z-index: 100; transition: opacity 0.8s ease;
}
.loader.hidden { opacity: 0; pointer-events: none; }
.loader-ring {
  width: 48px; height: 48px; border: 2px solid rgba(255,255,255,0.1);
  border-top-color: #6366f1; border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loader p { margin-top: 16px; font-size: 13px; color: rgba(255,255,255,0.4); }

/* Hint */
.hint {
  position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
  font-size: 12px; color: rgba(255,255,255,0.25); 
  animation: fadeHint 4s ease 3s forwards;
}
@keyframes fadeHint { to { opacity: 0; } }
</style>
</head>
<body>

<div class="loader" id="loader">
  <div class="loader-ring"></div>
  <p>Initializing Pulseâ€¦</p>
</div>

<div id="canvas-container"></div>

<div class="ui-overlay">
  <div class="brand">
    <h1>Pulse</h1>
    <p>Your AI's First Heartbeat</p>
  </div>

  <div class="module-bar">
    <button class="module-btn green" data-module="grow" onclick="toggleModule('grow')">
      <span class="dot"></span> Grow
    </button>
    <button class="module-btn blue" data-module="sense" onclick="toggleModule('sense')">
      <span class="dot"></span> Sense
    </button>
    <button class="module-btn gray" data-module="vision" onclick="toggleModule('vision')">
      <span class="dot"></span> Vision
    </button>
  </div>

  <div class="info-panel" id="info-panel">
    <h3 id="panel-title">Connected Module</h3>
    <div id="panel-content"></div>
  </div>

  <div class="hint">Drag to rotate Â· Click a module to connect</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

// ============ SCENE SETUP ============
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0f);

const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 1.2, 5.5);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// ============ ENVIRONMENT MAP (Procedural Studio) ============
function createStudioEnvironment() {
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  const envScene = new THREE.Scene();
  
  // Soft gradient background
  const topColor = new THREE.Color(0.15, 0.15, 0.2);
  const midColor = new THREE.Color(0.4, 0.4, 0.5);
  const botColor = new THREE.Color(0.05, 0.05, 0.08);
  
  // Large area lights simulating studio softboxes
  const light1Geo = new THREE.PlaneGeometry(4, 4);
  const light1Mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(2.5, 2.5, 2.8), side: THREE.DoubleSide });
  const light1 = new THREE.Mesh(light1Geo, light1Mat);
  light1.position.set(3, 3, 2);
  light1.lookAt(0, 0, 0);
  envScene.add(light1);

  const light2Mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(1.0, 1.0, 1.2), side: THREE.DoubleSide });
  const light2 = new THREE.Mesh(new THREE.PlaneGeometry(6, 3), light2Mat);
  light2.position.set(-4, 2, -1);
  light2.lookAt(0, 0, 0);
  envScene.add(light2);

  const light3Mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(1.8, 1.8, 2.2), side: THREE.DoubleSide });
  const light3 = new THREE.Mesh(new THREE.PlaneGeometry(3, 6), light3Mat);
  light3.position.set(0, 4, -3);
  light3.lookAt(0, 0, 0);
  envScene.add(light3);

  // Rim/accent light with slight color
  const light4Mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(0.6, 0.7, 1.5), side: THREE.DoubleSide });
  const light4 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), light4Mat);
  light4.position.set(-2, 1, 3);
  light4.lookAt(0, 0, 0);
  envScene.add(light4);

  // Ground fill 
  const groundMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(0.15, 0.15, 0.18), side: THREE.DoubleSide });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), groundMat);
  ground.position.set(0, -3, 0);
  ground.rotation.x = -Math.PI / 2;
  envScene.add(ground);

  const envMap = pmremGenerator.fromScene(envScene, 0.04).texture;
  pmremGenerator.dispose();
  return envMap;
}

const envMap = createStudioEnvironment();
scene.environment = envMap;

// ============ LIGHTS (Three-point) ============
// Key light
const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
keyLight.position.set(4, 6, 4);
keyLight.castShadow = true;
keyLight.shadow.mapSize.set(2048, 2048);
keyLight.shadow.camera.near = 0.5;
keyLight.shadow.camera.far = 20;
keyLight.shadow.camera.left = -3;
keyLight.shadow.camera.right = 3;
keyLight.shadow.camera.top = 3;
keyLight.shadow.camera.bottom = -3;
keyLight.shadow.bias = -0.0002;
keyLight.shadow.normalBias = 0.02;
scene.add(keyLight);

// Fill light (softer, from left)
const fillLight = new THREE.DirectionalLight(0xdde4ff, 0.6);
fillLight.position.set(-4, 2, 3);
scene.add(fillLight);

// Rim light (from behind)
const rimLight = new THREE.DirectionalLight(0xc8d0ff, 1.0);
rimLight.position.set(0, 3, -4);
scene.add(rimLight);

// Subtle ambient
const ambientLight = new THREE.AmbientLight(0x404060, 0.3);
scene.add(ambientLight);

// Brand accent light (indigo/cyan glow from screen area)
const accentLight = new THREE.PointLight(0x6366f1, 1.5, 6, 2);
accentLight.position.set(0, 0.2, 1.0);
scene.add(accentLight);

// ============ MATERIALS ============
const bodyMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xf0f0f2,
  roughness: 0.65,
  metalness: 0.05,
  clearcoat: 0.15,
  clearcoatRoughness: 0.4,
  sheen: 0.3,
  sheenRoughness: 0.5,
  sheenColor: new THREE.Color(0.9, 0.9, 1.0),
  envMapIntensity: 0.8,
});

const screenMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x111122,
  roughness: 0.05,
  metalness: 0.0,
  clearcoat: 1.0,
  clearcoatRoughness: 0.02,
  emissive: new THREE.Color(0x4338ca),
  emissiveIntensity: 0.3,
  envMapIntensity: 1.0,
});

const pogoPinMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xd4a843,
  roughness: 0.2,
  metalness: 1.0,
  envMapIntensity: 1.0,
});

const grillMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xd8d8dc,
  roughness: 0.5,
  metalness: 0.1,
  envMapIntensity: 0.6,
});

// ============ PULSE BODY (Lathe + details) ============
const pulseGroup = new THREE.Group();

// Pebble profile using LatheGeometry with custom curve
function createPebbleProfile() {
  // Half-profile of a pebble shape: flat bottom, rounded sides, slightly flat back
  const points = [];
  const segments = 64;
  
  // Parameters (in scene units, roughly 60Ã—65Ã—35mm scaled to ~2 units wide)
  const width = 1.0;   // half-width radius
  const height = 0.55;  // half-height
  
  // Generate smooth pebble cross-section using superellipse-like curve
  for (let i = 0; i <= segments; i++) {
    const t = i / segments; // 0 to 1, bottom to top
    const angle = t * Math.PI; // 0 to PI
    
    // Modified ellipse for pebble shape
    // Flatter on bottom, rounder on top
    let y = Math.cos(angle) * height;
    let r = Math.sin(angle) * width;
    
    // Flatten bottom
    if (t < 0.15) {
      r *= 0.6 + 0.4 * (t / 0.15);
      y = -height + t / 0.15 * height * 0.15;
    }
    
    points.push(new THREE.Vector2(Math.max(r, 0.001), y));
  }
  
  return points;
}

// Better approach: build pebble from subdivision of a custom shape
function createPebbleGeometry() {
  // Use a sphere as base, then deform it into pebble shape
  const geo = new THREE.SphereGeometry(1, 96, 64);
  const pos = geo.attributes.position;
  
  for (let i = 0; i < pos.count; i++) {
    let x = pos.getX(i);
    let y = pos.getY(i);
    let z = pos.getZ(i);
    
    // Normalize to unit sphere direction
    const len = Math.sqrt(x*x + y*y + z*z);
    const nx = x/len, ny = y/len, nz = z/len;
    
    // Pebble scaling: wider in X, slightly taller in Y, thinner in Z
    // Target proportions roughly 60:65:35 â†’ 1.0 : 1.08 : 0.58
    const sx = 1.0;
    const sy = 1.08;
    const sz = 0.54;
    
    // Apply superellipse deformation for rounder edges
    const px = nx * sx;
    const py = ny * sy;
    const pz = nz * sz;
    
    // Calculate radius at this direction for a superellipse-ish shape
    // Using power=3 for slightly squarish-but-round feel
    const p = 2.5; // power (2=ellipsoid, higher=more boxy with round edges)
    const dirLen = Math.pow(
      Math.pow(Math.abs(px), p) + Math.pow(Math.abs(py), p) + Math.pow(Math.abs(pz), p),
      1/p
    );
    
    const scale = 1.0 / Math.max(dirLen, 0.001);
    
    // Flatten bottom slightly
    let flattenFactor = 1.0;
    if (ny < -0.7) {
      flattenFactor = 0.85 + 0.15 * ((ny + 1.0) / 0.3);
    }
    
    // Flatten back (negative Z) slightly
    let backFlatten = 1.0;
    if (nz < -0.5) {
      backFlatten = 0.92 + 0.08 * ((nz + 1.0) / 0.5);
    }
    
    pos.setXYZ(i,
      px * scale * flattenFactor,
      py * scale * flattenFactor,
      pz * scale * backFlatten * flattenFactor
    );
  }
  
  geo.computeVertexNormals();
  return geo;
}

const pebbleGeo = createPebbleGeometry();
const pebbleMesh = new THREE.Mesh(pebbleGeo, bodyMaterial);
pebbleMesh.castShadow = true;
pebbleMesh.receiveShadow = true;
pulseGroup.add(pebbleMesh);

// ============ SCREEN (circular inset on front face) ============
// Screen bezel ring (slight depression)
const screenRadius = 0.38;
const screenGeo = new THREE.CircleGeometry(screenRadius, 64);

// Canvas texture for animated face
const faceCanvas = document.createElement('canvas');
faceCanvas.width = 512;
faceCanvas.height = 512;
const faceCtx = faceCanvas.getContext('2d');
const faceTexture = new THREE.CanvasTexture(faceCanvas);
faceTexture.colorSpace = THREE.SRGBColorSpace;

const screenFaceMaterial = new THREE.MeshPhysicalMaterial({
  map: faceTexture,
  roughness: 0.05,
  metalness: 0.0,
  clearcoat: 1.0,
  clearcoatRoughness: 0.02,
  emissive: new THREE.Color(0x6366f1),
  emissiveIntensity: 0.5,
  emissiveMap: faceTexture,
  envMapIntensity: 0.4,
});

const screenMesh = new THREE.Mesh(screenGeo, screenFaceMaterial);
screenMesh.position.set(0, 0.05, 0.535); // Slightly in front of body
screenMesh.name = 'screen';
pulseGroup.add(screenMesh);

// Screen bezel ring
const bezelGeo = new THREE.RingGeometry(screenRadius, screenRadius + 0.03, 64);
const bezelMat = new THREE.MeshPhysicalMaterial({
  color: 0x888899,
  roughness: 0.15,
  metalness: 0.8,
  envMapIntensity: 1.2,
});
const bezelMesh = new THREE.Mesh(bezelGeo, bezelMat);
bezelMesh.position.copy(screenMesh.position);
bezelMesh.position.z += 0.001;
pulseGroup.add(bezelMesh);

// ============ BACK GRILLE (horizontal lines) ============
const grilleGroup = new THREE.Group();
const grilleCount = 12;
for (let i = 0; i < grilleCount; i++) {
  const t = (i / (grilleCount - 1)) - 0.5; // -0.5 to 0.5
  const y = t * 0.7;
  const barWidth = 0.55 * Math.cos(t * Math.PI * 0.9); // Narrower at top/bottom
  if (barWidth < 0.05) continue;
  
  const barGeo = new THREE.BoxGeometry(barWidth, 0.012, 0.015);
  const barMesh = new THREE.Mesh(barGeo, grillMaterial);
  barMesh.position.set(0, y + 0.05, -0.535);
  barMesh.castShadow = true;
  grilleGroup.add(barMesh);
}
pulseGroup.add(grilleGroup);

// ============ POGO PINS (Bottom RWC Bus) ============
const pinGroup = new THREE.Group();
const pinCount = 8;
const pinSpacing = 0.08;
const pinStartX = -(pinCount - 1) * pinSpacing / 2;

for (let i = 0; i < pinCount; i++) {
  const pinGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.06, 16);
  const pin = new THREE.Mesh(pinGeo, pogoPinMaterial);
  pin.position.set(pinStartX + i * pinSpacing, -1.05, 0);
  pin.castShadow = true;
  pinGroup.add(pin);
}

// Bus connector housing
const busHousingGeo = new THREE.BoxGeometry(0.72, 0.05, 0.12);
const busHousingMat = new THREE.MeshPhysicalMaterial({
  color: 0x2a2a35,
  roughness: 0.4,
  metalness: 0.2,
});
const busHousing = new THREE.Mesh(busHousingGeo, busHousingMat);
busHousing.position.set(0, -1.07, 0);
pinGroup.add(busHousing);

pulseGroup.add(pinGroup);

pulseGroup.position.set(0, 0.3, 0);
scene.add(pulseGroup);

// ============ FACE ANIMATION ============
let currentEmotion = 'smile';
let blinkTimer = 0;
let isBlinking = false;
let breathPhase = 0;
let eyeOpenness = 1.0;

function drawFace(time) {
  const ctx = faceCtx;
  const w = 512, h = 512;
  const cx = w / 2, cy = h / 2;
  
  ctx.clearRect(0, 0, w, h);
  
  // Dark background with subtle radial gradient
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 220);
  grad.addColorStop(0, '#1a1a2e');
  grad.addColorStop(0.7, '#10101e');
  grad.addColorStop(1, '#0a0a14');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(cx, cy, 240, 0, Math.PI * 2);
  ctx.fill();
  
  // Breathing scale
  breathPhase += 0.015;
  const breathScale = 1.0 + Math.sin(breathPhase) * 0.015;
  
  // Blink logic
  blinkTimer += 0.016;
  if (!isBlinking && blinkTimer > 3 + Math.random() * 2) {
    isBlinking = true;
    blinkTimer = 0;
  }
  if (isBlinking) {
    const blinkProgress = blinkTimer / 0.15;
    if (blinkProgress < 0.5) {
      eyeOpenness = 1.0 - blinkProgress * 2;
    } else if (blinkProgress < 1.0) {
      eyeOpenness = (blinkProgress - 0.5) * 2;
    } else {
      eyeOpenness = 1.0;
      isBlinking = false;
      blinkTimer = 0;
    }
  }
  
  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(breathScale, breathScale);
  
  // Line style
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  if (currentEmotion === 'smile') {
    // Eyes: happy curved lines (^  ^)
    ctx.strokeStyle = '#c7d2fe';
    ctx.lineWidth = 5;
    ctx.shadowColor = '#818cf8';
    ctx.shadowBlur = 12;
    
    // Left eye
    const eyeY = -25;
    const eyeSpread = 50;
    const eyeH = 18 * eyeOpenness;
    
    ctx.beginPath();
    ctx.moveTo(-eyeSpread - 22, eyeY + eyeH * 0.3);
    ctx.quadraticCurveTo(-eyeSpread, eyeY - eyeH, -eyeSpread + 22, eyeY + eyeH * 0.3);
    ctx.stroke();
    
    // Right eye
    ctx.beginPath();
    ctx.moveTo(eyeSpread - 22, eyeY + eyeH * 0.3);
    ctx.quadraticCurveTo(eyeSpread, eyeY - eyeH, eyeSpread + 22, eyeY + eyeH * 0.3);
    ctx.stroke();
    
    // Smile
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(0, 15, 28, 0.15 * Math.PI, 0.85 * Math.PI, false);
    ctx.stroke();
    
  } else if (currentEmotion === 'excited') {
    // Star eyes
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 15;
    
    const drawStar = (cx2, cy2, r) => {
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = -Math.PI/2 + (i * Math.PI * 2 / 5);
        const angleInner = angle + Math.PI / 5;
        ctx.lineTo(cx2 + Math.cos(angle) * r, cy2 + Math.sin(angle) * r);
        ctx.lineTo(cx2 + Math.cos(angleInner) * r * 0.4, cy2 + Math.sin(angleInner) * r * 0.4);
      }
      ctx.closePath();
      ctx.stroke();
    };
    
    const rotOff = Math.sin(time * 2) * 0.1;
    ctx.save();
    ctx.translate(-50, -25);
    ctx.rotate(rotOff);
    drawStar(0, 0, 18 * eyeOpenness);
    ctx.restore();
    ctx.save();
    ctx.translate(50, -25);
    ctx.rotate(-rotOff);
    drawStar(0, 0, 18 * eyeOpenness);
    ctx.restore();
    
    // Big smile
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 4.5;
    ctx.beginPath();
    ctx.arc(0, 12, 32, 0.1 * Math.PI, 0.9 * Math.PI, false);
    ctx.stroke();
    
  } else if (currentEmotion === 'curious') {
    // One eye bigger, tilted head feel
    ctx.strokeStyle = '#67e8f9';
    ctx.lineWidth = 4.5;
    ctx.shadowColor = '#22d3ee';
    ctx.shadowBlur = 12;
    
    // Left eye: circle (big, curious)
    const leftR = 16 * eyeOpenness;
    ctx.beginPath();
    ctx.arc(-45, -22, leftR, 0, Math.PI * 2);
    ctx.stroke();
    // Pupil dot
    ctx.fillStyle = '#67e8f9';
    ctx.beginPath();
    ctx.arc(-45 + 4, -24, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Right eye: smaller circle
    const rightR = 12 * eyeOpenness;
    ctx.beginPath();
    ctx.arc(50, -20, rightR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(50 + 3, -22, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Small 'o' mouth
    ctx.lineWidth = 3.5;
    ctx.beginPath();
    ctx.arc(5, 25, 10, 0, Math.PI * 2);
    ctx.stroke();
    
  } else if (currentEmotion === 'focused') {
    // Determined/focused look (â€” â€”) slight frown of concentration
    ctx.strokeStyle = '#a78bfa';
    ctx.lineWidth = 5;
    ctx.shadowColor = '#7c3aed';
    ctx.shadowBlur = 12;
    
    // Flat eyes
    const eyeH = 3 * eyeOpenness;
    ctx.beginPath();
    ctx.moveTo(-65, -22 - eyeH); ctx.lineTo(-30, -25 - eyeH);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(30, -25 - eyeH); ctx.lineTo(65, -22 - eyeH);
    ctx.stroke();
    
    // Focused line mouth
    ctx.lineWidth = 3.5;
    ctx.beginPath();
    ctx.moveTo(-18, 22);
    ctx.lineTo(18, 22);
    ctx.stroke();
  }
  
  ctx.restore();
  faceTexture.needsUpdate = true;
}

// ============ CONTACT SHADOW (Ground plane) ============
const shadowGeo = new THREE.PlaneGeometry(6, 6);
const shadowCanvas = document.createElement('canvas');
shadowCanvas.width = 256;
shadowCanvas.height = 256;
const sCtx = shadowCanvas.getContext('2d');
const sGrad = sCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
sGrad.addColorStop(0, 'rgba(0,0,0,0.35)');
sGrad.addColorStop(0.4, 'rgba(0,0,0,0.15)');
sGrad.addColorStop(1, 'rgba(0,0,0,0)');
sCtx.fillStyle = sGrad;
sCtx.fillRect(0, 0, 256, 256);
const shadowTex = new THREE.CanvasTexture(shadowCanvas);
const shadowMat = new THREE.MeshBasicMaterial({ map: shadowTex, transparent: true, depthWrite: false });
const shadowPlane = new THREE.Mesh(shadowGeo, shadowMat);
shadowPlane.rotation.x = -Math.PI / 2;
shadowPlane.position.y = -1.1;
scene.add(shadowPlane);

// Ground reflection plane (subtle)
const groundGeo = new THREE.PlaneGeometry(20, 20);
const groundMat = new THREE.MeshPhysicalMaterial({
  color: 0x0a0a0f,
  roughness: 0.85,
  metalness: 0.1,
  envMapIntensity: 0.15,
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -1.12;
ground.receiveShadow = true;
scene.add(ground);

// ============ MODULES ============
const modules = {};
const moduleInfos = {
  grow: {
    title: 'Grow Module',
    emotion: 'excited',
    capabilities: [
      { title: 'ðŸŒ± Soil Moisture', desc: 'Capacitive sensor, Â±2% accuracy' },
      { title: 'ðŸ’§ Auto Irrigation', desc: 'Peristaltic pump, 0-100ml/min' },
      { title: 'ðŸŒ¡ï¸ Soil Temperature', desc: 'NTC probe, -20Â°C to 80Â°C' },
    ]
  },
  sense: {
    title: 'Sense Module',
    emotion: 'curious',
    capabilities: [
      { title: 'ðŸŒ¡ï¸ Temperature', desc: 'BME680, Â±0.5Â°C' },
      { title: 'ðŸ’¨ Air Quality', desc: 'VOC + COâ‚‚ equivalent' },
      { title: 'ðŸ’§ Humidity', desc: '0-100% RH, Â±3%' },
      { title: 'ðŸ“Š Pressure', desc: '300-1100 hPa' },
    ]
  },
  vision: {
    title: 'Vision Module',
    emotion: 'focused',
    capabilities: [
      { title: 'ðŸ“· Camera', desc: 'OV5640, 5MP, 1080p30' },
      { title: 'ðŸ§  On-device ML', desc: 'Person/pet detection' },
      { title: 'ðŸ” Object Recognition', desc: 'TFLite models, <100ms' },
    ]
  }
};

// Grow Module: cylinder with probe on top, pipe on side
function createGrowModule() {
  const group = new THREE.Group();
  const mat = new THREE.MeshPhysicalMaterial({
    color: 0x6b9a6b, roughness: 0.55, metalness: 0.05,
    clearcoat: 0.1, envMapIntensity: 0.7,
  });
  
  // Main cylinder body
  const bodyGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.35, 32);
  const body = new THREE.Mesh(bodyGeo, mat);
  group.add(body);
  
  // Top cap (slightly lighter)
  const capMat = new THREE.MeshPhysicalMaterial({
    color: 0x7aaa7a, roughness: 0.4, metalness: 0.05, envMapIntensity: 0.7,
  });
  const capGeo = new THREE.CylinderGeometry(0.23, 0.23, 0.03, 32);
  const cap = new THREE.Mesh(capGeo, capMat);
  cap.position.y = 0.19;
  group.add(cap);
  
  // Probe (thin cone on top)
  const probeGeo = new THREE.ConeGeometry(0.025, 0.35, 16);
  const probeMat = new THREE.MeshPhysicalMaterial({
    color: 0x888888, roughness: 0.3, metalness: 0.7, envMapIntensity: 1.0,
  });
  const probe = new THREE.Mesh(probeGeo, probeMat);
  probe.position.set(0.06, 0.38, 0);
  group.add(probe);
  
  // Side pipe (small tube)
  const pipeGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.12, 16);
  const pipe = new THREE.Mesh(pipeGeo, probeMat);
  pipe.position.set(0.22, -0.05, 0);
  pipe.rotation.z = Math.PI / 2;
  group.add(pipe);
  
  // Bottom pogo receptacle
  const receptGeo = new THREE.BoxGeometry(0.35, 0.03, 0.08);
  const receptMat = new THREE.MeshPhysicalMaterial({
    color: 0x2a2a30, roughness: 0.4, metalness: 0.3,
  });
  const recept = new THREE.Mesh(receptGeo, receptMat);
  recept.position.y = -0.19;
  group.add(recept);
  
  group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
  return group;
}

// Sense Module: rounded box with 4 sensor holes
function createSenseModule() {
  const group = new THREE.Group();
  const mat = new THREE.MeshPhysicalMaterial({
    color: 0x5b7baa, roughness: 0.5, metalness: 0.05,
    clearcoat: 0.15, envMapIntensity: 0.7,
  });
  
  // Rounded box body (approximate with beveled extrude)
  const shape = new THREE.Shape();
  const w = 0.18, h = 0.18, r = 0.05;
  shape.moveTo(-w + r, -h);
  shape.lineTo(w - r, -h);
  shape.quadraticCurveTo(w, -h, w, -h + r);
  shape.lineTo(w, h - r);
  shape.quadraticCurveTo(w, h, w - r, h);
  shape.lineTo(-w + r, h);
  shape.quadraticCurveTo(-w, h, -w, h - r);
  shape.lineTo(-w, -h + r);
  shape.quadraticCurveTo(-w, -h, -w + r, -h);
  
  const extrudeSettings = {
    depth: 0.28,
    bevelEnabled: true,
    bevelThickness: 0.03,
    bevelSize: 0.03,
    bevelSegments: 6,
  };
  const bodyGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  bodyGeo.center();
  const body = new THREE.Mesh(bodyGeo, mat);
  body.rotation.x = Math.PI / 2;
  group.add(body);
  
  // 4 sensor holes on top
  const holeMat = new THREE.MeshPhysicalMaterial({
    color: 0x1a2a3a, roughness: 0.8, metalness: 0.0,
  });
  const holePositions = [[-0.07, -0.07], [0.07, -0.07], [-0.07, 0.07], [0.07, 0.07]];
  holePositions.forEach(([hx, hz]) => {
    const holeGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.02, 16);
    const hole = new THREE.Mesh(holeGeo, holeMat);
    hole.position.set(hx, 0.175, hz);
    group.add(hole);
  });
  
  // Bottom connector
  const receptGeo = new THREE.BoxGeometry(0.25, 0.025, 0.06);
  const receptMat = new THREE.MeshPhysicalMaterial({ color: 0x2a2a30, roughness: 0.4, metalness: 0.3 });
  const recept = new THREE.Mesh(receptGeo, receptMat);
  recept.position.y = -0.175;
  group.add(recept);
  
  group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
  return group;
}

// Vision Module: flat disc with concentric lens rings
function createVisionModule() {
  const group = new THREE.Group();
  const mat = new THREE.MeshPhysicalMaterial({
    color: 0x3a3a42, roughness: 0.45, metalness: 0.1,
    clearcoat: 0.1, envMapIntensity: 0.8,
  });
  
  // Flat disc body
  const bodyGeo = new THREE.CylinderGeometry(0.24, 0.24, 0.18, 48);
  const body = new THREE.Mesh(bodyGeo, mat);
  group.add(body);
  
  // Lens bezel (concentric rings on top)
  const ringMat = new THREE.MeshPhysicalMaterial({
    color: 0x2a2a30, roughness: 0.2, metalness: 0.6, envMapIntensity: 1.0,
  });
  
  [0.18, 0.14, 0.10].forEach((r, i) => {
    const ringGeo = new THREE.TorusGeometry(r, 0.008, 8, 48);
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.y = 0.092;
    ring.rotation.x = Math.PI / 2;
    group.add(ring);
  });
  
  // Center lens (glass-like)
  const lensGeo = new THREE.SphereGeometry(0.06, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0x111122,
    roughness: 0.0,
    metalness: 0.0,
    transmission: 0.6,
    thickness: 0.5,
    ior: 1.8,
    clearcoat: 1.0,
    envMapIntensity: 1.5,
  });
  const lens = new THREE.Mesh(lensGeo, lensMat);
  lens.position.y = 0.09;
  group.add(lens);
  
  // Bottom connector
  const receptGeo = new THREE.BoxGeometry(0.25, 0.025, 0.06);
  const receptMat = new THREE.MeshPhysicalMaterial({ color: 0x2a2a30, roughness: 0.4, metalness: 0.3 });
  const recept = new THREE.Mesh(receptGeo, receptMat);
  recept.position.y = -0.092;
  group.add(recept);
  
  group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
  return group;
}

// Create and position modules off to the sides
const growModule = createGrowModule();
growModule.position.set(-2.5, -0.4, 1.5);
growModule.userData = { 
  restPos: new THREE.Vector3(-2.5, -0.4, 1.5),
  connectedPos: new THREE.Vector3(0, -0.95, 0),
  type: 'grow'
};
scene.add(growModule);
modules.grow = growModule;

const senseModule = createSenseModule();
senseModule.position.set(0, -0.5, 2.5);
senseModule.userData = {
  restPos: new THREE.Vector3(0, -0.5, 2.5),
  connectedPos: new THREE.Vector3(0, -0.95, 0),
  type: 'sense'
};
scene.add(senseModule);
modules.sense = senseModule;

const visionModule = createVisionModule();
visionModule.position.set(2.5, -0.4, 1.5);
visionModule.userData = {
  restPos: new THREE.Vector3(2.5, -0.4, 1.5),
  connectedPos: new THREE.Vector3(0, -0.95, 0),
  type: 'vision'
};
scene.add(visionModule);
modules.vision = visionModule;

// ============ CONTROLS ============
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.enablePan = false;
controls.minDistance = 3;
controls.maxDistance = 9;
controls.minPolarAngle = Math.PI * 0.15;
controls.maxPolarAngle = Math.PI * 0.75;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.6;
controls.target.set(0, 0.1, 0);

let idleTimer;
controls.addEventListener('start', () => {
  controls.autoRotate = false;
  clearTimeout(idleTimer);
});
controls.addEventListener('end', () => {
  idleTimer = setTimeout(() => { controls.autoRotate = true; }, 4000);
});

// ============ POST-PROCESSING ============
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.25,  // strength
  0.5,   // radius
  0.82   // threshold
);
composer.addPass(bloomPass);

const fxaaPass = new ShaderPass(FXAAShader);
fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
composer.addPass(fxaaPass);

// ============ MODULE INTERACTION ============
let connectedModule = null;
let animating = false;

function easeOutElastic(t) {
  const p = 0.4;
  return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

window.toggleModule = function(type) {
  if (animating) return;
  
  const mod = modules[type];
  const info = moduleInfos[type];
  const btn = document.querySelector(`[data-module="${type}"]`);
  const panel = document.getElementById('info-panel');
  
  // If this module is already connected, disconnect it
  if (connectedModule === type) {
    animating = true;
    // Animate back to rest
    animateModuleToPosition(mod, mod.userData.restPos, 800, () => {
      animating = false;
      connectedModule = null;
      currentEmotion = 'smile';
      btn.classList.remove('active');
      panel.classList.remove('visible');
      // Reset accent light
      accentLight.color.set(0x6366f1);
      accentLight.intensity = 1.5;
    });
    return;
  }
  
  // If another module is connected, disconnect it first
  if (connectedModule) {
    const oldMod = modules[connectedModule];
    const oldBtn = document.querySelector(`[data-module="${connectedModule}"]`);
    oldBtn.classList.remove('active');
    animateModuleToPosition(oldMod, oldMod.userData.restPos, 500);
  }
  
  animating = true;
  
  // Animate module to connected position
  animateModuleToPosition(mod, mod.userData.connectedPos, 900, () => {
    animating = false;
    connectedModule = type;
    currentEmotion = info.emotion;
    
    // Pulse glow effect
    pulseGlow();
    
    // Update UI
    btn.classList.add('active');
    document.querySelectorAll('.module-btn').forEach(b => {
      if (b.dataset.module !== type) b.classList.remove('active');
    });
    
    // Show info panel
    document.getElementById('panel-title').textContent = info.title;
    document.getElementById('panel-content').innerHTML = info.capabilities.map(c => 
      `<div class="capability"><div class="cap-title">${c.title}</div>${c.desc}</div>`
    ).join('');
    panel.classList.add('visible');
    
    // Change accent light color
    const colors = { grow: 0x4ade80, sense: 0x60a5fa, vision: 0x9ca3af };
    accentLight.color.set(colors[type]);
  });
};

function animateModuleToPosition(mod, targetPos, duration, onComplete) {
  const startPos = mod.position.clone();
  const startTime = performance.now();
  
  function tick() {
    const elapsed = performance.now() - startTime;
    const t = Math.min(elapsed / duration, 1);
    const ease = easeOutElastic(t);
    
    mod.position.lerpVectors(startPos, targetPos, Math.min(ease, 1.0));
    
    if (t < 1) {
      requestAnimationFrame(tick);
    } else {
      mod.position.copy(targetPos);
      if (onComplete) onComplete();
    }
  }
  tick();
}

let glowPulseActive = false;
function pulseGlow() {
  glowPulseActive = true;
  const startTime = performance.now();
  function tick() {
    const t = (performance.now() - startTime) / 1200;
    if (t > 1) {
      screenFaceMaterial.emissiveIntensity = 0.5;
      accentLight.intensity = 1.5;
      glowPulseActive = false;
      return;
    }
    // Quick bright pulse then settle
    const pulse = Math.sin(t * Math.PI * 3) * Math.exp(-t * 3);
    screenFaceMaterial.emissiveIntensity = 0.5 + pulse * 1.5;
    accentLight.intensity = 1.5 + pulse * 4;
    requestAnimationFrame(tick);
  }
  tick();
}

// ============ FLOAT ANIMATION FOR MODULES ============
function floatModules(time) {
  Object.entries(modules).forEach(([type, mod]) => {
    if (connectedModule === type) return; // Don't float if connected
    const baseY = mod.userData.restPos.y;
    mod.position.y = baseY + Math.sin(time * 1.2 + type.length) * 0.04;
    mod.rotation.y = Math.sin(time * 0.8 + type.length * 2) * 0.1;
  });
}

// ============ RESIZE ============
function onResize() {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
  fxaaPass.uniforms['resolution'].value.set(1 / w, 1 / h);
}
window.addEventListener('resize', onResize);

// ============ ANIMATION LOOP ============
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const time = clock.getElapsedTime();
  
  controls.update();
  
  // Animate face
  drawFace(time);
  
  // Float modules
  floatModules(time);
  
  // Subtle Pulse body float
  pulseGroup.position.y = 0.3 + Math.sin(time * 0.8) * 0.02;
  pulseGroup.rotation.y = Math.sin(time * 0.3) * 0.02;
  
  composer.render();
}

// ============ START ============
// Hide loader after a brief moment
setTimeout(() => {
  document.getElementById('loader').classList.add('hidden');
}, 800);

animate();
</script>
</body>
</html>
